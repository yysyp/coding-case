===================================================================================================================================================
##1**Java基础与原理 (10分钟)**


   **问题1：** 假设有一个 `HashMap<Integer, Object>` 在高并发环境下被频繁读写，会出现什么问题？如何解决？
   - **考察点：** 并发编程基础、JUC实战经验。
   - **参考答案：**
       - **问题：**
           1.  **数据错乱：** 多线程put可能导致元素丢失。
           2.  **死循环：** JDK1.7及以前，并发扩容可能导致链表形成环，引起CPU 100%。（可考察其对细节的了解）
           3.  **快速失败：** 迭代时修改会抛出 `ConcurrentModificationException`。
       - **解决方案：**
           - 使用 `ConcurrentHashMap`。
           - 使用 `Collections.synchronizedMap(new HashMap<>())`（性能较差）。
           - **深入追问：** `ConcurrentHashMap` 在JDK1.8中是如何保证线程安全的？（答：synchronized + CAS +  volatile， 锁的粒度是链表头节点或红黑树根节点）
   ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。 针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap 就像是一个大篮子，
   现在这个篮子里有 900 个桔子，我们期望把这个篮子装满 1000 个桔子，也就是再装 100 个桔子。有 10 个工人来干这件事儿，
   大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。ConcurrentHashMap 这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，
   但无法确保工人 A 看到还需要装 100 个桔子但是还未装的时候，工人 B 就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装 100 个桔子的操作不是原子性的，
   在别人看来可能会有一个瞬间篮子里有 964 个桔子，还需要补 36 个桔子。回到 ConcurrentHashMap，我们需要注意 ConcurrentHashMap 对外提供的方法或能力
   的限制：使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。诸如 size、isEmpty
   和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。
   显然，利用 size 方法计算差异值，是一个流程控制。诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。
   **computeIfAbsent 为什么如此高效呢？答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多.
   **CopyOnWriteArrayList 在 Java 中，CopyOnWriteArrayList 虽然是一个线程安全的 ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。


   **问题2：** 谈谈你对 `synchronized` 和 `ReentrantLock` 的理解。它们有什么区别？在高并发场景下，如何选择？
   - **考察点：** 并发编程基本功，对锁机制的掌握深度。
   - **参考答案：**
     - **相同点：** 都是可重入锁，用于保证线程安全。
     - **不同点：**
       - **底层机制：** `synchronized` 是JVM关键字，通过字节码指令`monitorenter/monitorexit`实现；`ReentrantLock` 是JDK提供的API。
       - **灵活性：** `ReentrantLock` 更灵活，可以尝试非阻塞获取锁(`tryLock`)、可中断(`lockInterruptibly`)、公平锁等。`synchronized` 是非公平锁。
       - **条件变量：** `ReentrantLock` 可以绑定多个`Condition`，实现精细的线程等待/唤醒。`synchronized` 只有一个等待集。
     - **选择策略：**
       - 优先使用 `synchronized`：代码简洁，由JVM维护，不易出错。
       - 需要**高级功能**（如定时锁等待、可中断、公平性）时，使用 `ReentrantLock`。
     synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。
     ** Java SDK 并发包通过 Lock 和 Condition 两个接口也可以用来实现管程并且支持多个条件变量，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。
     Lock接口提供了破坏不可抢占条件的方法：
     - 1，阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它。 void lockInterruptibly() throws InterruptedException;
     - 2，支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误。 boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
     - 3，非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。 boolean tryLock();


   **有一个共享变量 abc，在一个线程里设置了 abc 的值 abc=3，你思考一下，有哪些办法可 以让其他线程能够看到abc==3？
   - 1, 使用volatile修饰abc, 禁止CPU缓存，直接从内存获取和volatile写happen before volatile读。
   - 2，synchronized 代码块中操作abc，解锁happen before 后续的加锁。
   - 3，线程A操作共享变量abc，然后start方法启动B线程，B线程中可见abc操作。
   - 4，线程A操作共享变量abc, B join A, 对于B线程可见。
   ** get方法加锁不是为了解决原子性问题，这个操作本身就是原子性的，是为了实现不能线程间addone方法的操作结果对get方法可见。
   那么value变量加volitile也可以实现同样的效果，并发包的原子类就是靠它实现的。 get方法不用synchronized，value加volitile也能保证可见性，这是对的。
   但是如果真这么做了，原子性可能被打破。synchronized并 不保证线程不被中断。如果在写高低两个字节的中间写线程被中断，而读线程被调用执行，因为读没尝试加锁，
   所以可以读到写了一半的结果。


   ** 如何保证多线程同时访问多个资源不导致死锁？
   ** 如何避免死锁呢？要避免死锁就需要分析死锁发生的条件，有个叫 Coffman 的牛人早 就总结过了，
   - 只有以下这四个条件都发生时才会出现死锁：
   - 互斥，共享资源 X 和 Y 只能被一个线程占用；
   - 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源X；
   - 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
   - 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
   反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。
   String，Integer等基本类型，Java的实现里面都优化为不可变对象对象池，一但对他们进行赋值就会变成新的对象，所以如果用这些对象作为锁，
   那么有会有锁失效的问题（因为对象是另外一个了，加锁会加在不同的对象上）。
   解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。
   ** 乐观锁如何避免ABA问题 ?


   ** 单例模式：
   class Singleton {
       private static volatile Singleton singleton;
       //构造方法私有化
       private Singleton() {}

       //获取实例（单例）
       public static Singleton getInstance() {
        //第一次检查
        if(singleton==null) {
            synchronize(Singleton.class) {
                //获取锁后二次检查
                12/30
                if(singleton==null) {
                    singleton=new Singleton();
                }
            }
        }
        return singleton;
       }
   }
   **直接用枚举实现，枚举实现是自动单例且懒加载的。


   ** Exception 和 Error 的区别： Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），
   它是异常处理机制的基本组成类型。 Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，
   可能并且应该被捕获，进行相应处理。 Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。
   既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。 Exception 又分为可检查（checked）异常和不检查（unchecked）异常，
   可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。不检查异常就是所谓的运行时异常，
   类似 NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。


   ** 动态代理是基于什么原理？ 反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。
   通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。
   动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。
   实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，
   类似 ASM、cglib（基于 ASM）、Javassist 等。


   ** Java并发包提供了哪些并发工具类？ 我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：
   提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。
   各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。
   各种并发队列实现，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。
   强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。


   ** 谈谈你的GC调优思路? 谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，
   内存占用（footprint）、延时（latency）和吞吐量（throughput），
   大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，
   例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。 基本的调优思路可以总结为：
    理解应用需求和问题，确定调优目标。
    假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。
    掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。
    例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。
    这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。
    通过分析确定具体调整的参数或者软硬件配置。
    验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。


    **Java乱码问题的原因是什么，怎么解决？


    **Java线程池有哪些配置参数？


    ** 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？
    所谓隔离级别（Isolation Level），就是在数据库事务中，为保证并发数据读写的正确性而提出的定义，它并不是 MySQL 专有的概念，
    而是源于ANSI/ISO制定的SQL-92标准。 每种关系型数据库都提供了各自特色的隔离级别实现，虽然在通常的定义中是以锁为实现单元，但实际的实现千差万别。
    以最常见的 MySQL InnoDB 引擎为例，它是基于 MVCC（Multi-Versioning Concurrency Control）和锁的复合实现，按照隔离程度从低到高，
    MySQL 事务隔离级别分为四个不同层次：
    -读未提交（Read uncommitted），就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许脏读出现。
    -读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许不可重复读和幻象读（Phantom Read）出现。
    -可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读。
    -串行化（Serializable），并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别。
    至于悲观锁和乐观锁，也并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。主要区别在于，操作共享数据时，“悲观锁”即认为数据出现冲突的可能性更大，而“乐观锁”则是认为大部分情况不会出现冲突，进而决定是否采取排他性措施。
    反映到 MySQL 数据库应用开发中，悲观锁一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。
    我认为前面提到的 MVCC，其本质就可以看作是种乐观锁机制，而排他性的读写锁、双阶段锁等则是悲观锁的实现。
    有关它们的应用场景，你可以构建一下简化的火车余票查询和购票系统。同时查询的人可能很多，虽然具体座位票只能是卖给一个人，但余票可能很多，而且也并不能预测哪个查询者会购票，这个时候就更适合用乐观锁。


    ** 设计模式 **
    - **问题：** 请举例说明你在项目中是如何使用设计模式的？它带来了什么好处？
    - **考察点：** 代码设计思想与实践经验，而非死记硬背。
    - **参考答案：**
     - **示例1（模板方法模式）：** 在多个支付渠道（微信、支付宝）的处理流程中，定义了抽象的 `AbstractPayService`，将支付、回调、查询等公共流程固化在模板方法中，子类只需实现各自渠道的特定步骤。**好处：** 代码复用，结构清晰，流程统一，易于扩展新渠道。
     - **示例2（策略模式）：** 针对不同的用户类型（新用户、老用户、VIP用户），有不同的折扣计算策略。我们定义了 `DiscountStrategy` 接口和多个实现类，通过上下文在运行时选择合适的策略。**好处：** 消除了复杂的if-else分支，符合开闭原则，策略可以灵活替换和扩展。


------------------------------------------------------------------------------------------------------------------------
##2** Spring框架深度 (10分钟)**

   ** SpringMVC @Controller, @RestController区别？


   **问题：** Spring Bean的生命周期是怎样的？请尽可能详细地描述。
   - **考察点：** 对IoC容器核心原理的理解。
   - **参考答案：**
     1. **实例化：** 通过反射创建Bean实例。
     2. **属性赋值：** 为Bean的属性注入值（依赖注入）。
     3. **Aware接口回调：** 如果实现了 `BeanNameAware`, `BeanFactoryAware` 等接口，会调用相应方法。
     4. **BeanPostProcessor前置处理：** 调用 `postProcessBeforeInitialization` 方法。
     5. **初始化：** 调用 `InitializingBean` 的 `afterPropertiesSet` 方法和自定义的 `init-method`。
     6. **BeanPostProcessor后置处理：** 调用 `postProcessAfterInitialization` 方法（这里是AOP代理生成的关键）。
     7. **使用：** Bean完全可用，存在于Spring容器中。
     8. **销毁：** 容器关闭时，调用 `DisposableBean` 的 `destroy` 方法和自定义的 `destroy-method`。
   **Spring Bean的生命周期?粗略分为5个阶段:实例化、属性赋值、初始化、使用、销毁。
   **问题2：** Spring Bean的实例化过程是怎样的？什么是循环依赖？Spring是如何解决循环依赖的？
   - **考察点：** 对IoC容器核心原理的掌握深度。
   - **参考答案：**
   - **生命周期：** 实例化 -> 属性填充（依赖注入） -> 初始化（`InitializingBean`, `init-method`）等。
   - **循环依赖：** A依赖B，B也依赖A。
   - **解决方案：** Spring通过**三级缓存**解决Setter注入的循环依赖。
       - **一级缓存（单例池）：** 存放完整的Bean。
       - **二级缓存：** 存放提前暴露的早期Bean（未填充属性）。
       - **三级缓存：** 存放Bean的工厂对象，用于生成AOP代理对象。
   - **过程：** 创建A -> 提前暴露A（放入三级缓存）-> 填充A属性时发现需要B -> 创建B -> 填充B属性时发现需要A -> 从三级缓存拿到A的工厂获取早期A -> B创建完成 -> A完成创建。**注意：构造器注入无法解决循环依赖。**


    **1. 基础问题：解释一下AOP是什么？有哪些核心概念？你如何在项目中使用AOP？**
    - **考察点：** 对AOP思想的理解和实战经验。
    - **参考答案：**
    - **是什么：** AOP（面向切面编程）是一种编程范式，允许将横切关注点（如日志、事务、安全）从业务逻辑中分离出来，提高模块化。
    - **核心概念：**
        - **Aspect：** 切面，封装横切逻辑的模块（如一个`@Aspect`类）。
        - **Joinpoint：** 连接点，程序执行过程中的一个点（如方法执行、异常处理）。
        - **Advice：** 通知，在特定连接点上执行的动作（如`@Before`, `@After`, `@Around`）。
        - **Pointcut：** 切入点，匹配连接点的表达式，定义了通知在何处执行。
        - **Weaving：** 织入，将切面应用到目标对象并创建代理对象的过程。
    - **实战应用：**
        - **日志记录：** 使用`@Around`通知记录方法的入参、出参和执行时间。
        - **事务管理：** `@Transactional` 注解的本质就是基于AOP实现的。
        - **权限校验：** 在方法执行前（`@Before`）检查用户权限。
        - **全局异常处理：** 使用`@AfterThrowing`通知进行统一的异常转换和记录。


    **Spring事务管理：@Transactional 注解的原理是什么？在什么情况下会失效？
    参考答案：
    原理： 基于AOP。在调用被@Transactional注解的方法时，Spring会创建一个代理对象。代理逻辑会：
    根据方法是否抛出异常来提交或回滚事务。
    常见失效场景：
    1，方法非public： @Transactional 只能用于public方法。
    2，自调用问题： 同一个类中，一个非事务方法A调用一个事务方法B，事务不会生效。因为自调用不走代理。
    3，异常被捕获： 方法中抛出的异常被try-catch捕获，而未被抛出，事务管理器无法感知异常，会正常提交。
    4，默认只回滚RuntimeException和Error： 如果抛出的是受检异常（如Exception），默认不会回滚。需要用 @Transactional(rollbackFor = Exception.class) 指定。
    5，数据库引擎不支持： 如使用MyISAM引擎，它本身不支持事务。


    **1. Spring MVC：描述一下Spring MVC处理一个HTTP请求的完整流程。**
    - **考察点：** 对MVC框架核心流程的熟悉度。
    - **参考答案：**
    1.  **DispatcherServlet：** 作为前端控制器，接收所有请求。
    2.  **HandlerMapping：** `DispatcherServlet` 查询一个或多个 `HandlerMapping`，找到处理请求的Controller和方法（Handler）。
    3.  **HandlerAdapter：** `DispatcherServlet` 通过 `HandlerAdapter` 来实际执行找到的Handler。
    4.  **执行Handler：** `HandlerAdapter` 调用Controller中的方法，执行业务逻辑。
    5.  **返回ModelAndView：** Handler执行完成后，返回一个 `ModelAndView` 对象（包含模型数据和视图名）。
    6.  **视图解析：** `DispatcherServlet` 将视图名交给 `ViewResolver` 来解析为具体的 `View` 对象。
    7.  **渲染视图：** `View` 对象结合Model数据，渲染输出（如生成HTML、JSON）。
    8.  **返回响应：** 将渲染结果返回给客户端。


    **2. Spring Boot：Spring Boot的自动配置是如何工作的？**
    - **考察点：** 对Spring Boot“约定优于配置”核心原理的理解。
    - **参考答案：**
    - **核心机制：** 基于 `@EnableAutoConfiguration` 注解。
    - **工作流程：**
        1.  Spring Boot在启动时会加载 `META-INF/spring.factories` 文件，其中定义了大量的自动配置类（`XXXAutoConfiguration`）。
        2.  这些自动配置类使用 `@Conditional` 及其派生注解（如 `@ConditionalOnClass`, `@ConditionalOnProperty`, `@ConditionalOnMissingBean`）进行条件化装配。
        3.  只有当条件满足时（例如，类路径下存在某个特定的类、配置了某个属性、容器中没有某个Bean），自动配置类才会生效。
        4.  生效的自动配置类会向容器中注入预先配置好的Bean。
    - **举例：** 当类路径下存在 `DataSource.class` 时，`DataSourceAutoConfiguration` 才会生效，并尝试根据 `application.properties` 中的配置创建一个数据源Bean。


------------------------------------------------------------------------------------------------------------------------
##3** 中间件 (10分钟)**

1.  **MySQL：** 一张订单表数据量巨大，`SELECT * FROM orders WHERE user_id = ? AND status = 'UNPAID'` 查询很慢，你如何优化？
    - **考察点：** SQL优化和索引设计的实战能力。
    - **参考答案：**
        - **第一步：** `EXPLAIN` 分析，看是否全表扫描。
        - **第二步：** 为 `(user_id, status)` 创建**联合索引**。因为 `user_id` 的区分度通常更高，放在前面。
        - **深入追问：** 为什么这个联合索引有效？（答：索引覆盖了查询条件，可以利用B+树快速定位）
        - **其他优化：** 如果查询字段很少，可以考虑创建**覆盖索引** `(user_id, status, order_id, amount)` 避免回表。最终，对历史订单进行**分库分表**。
    一条SQL执行时间过长，如何优化？ 1，SQL是否涉及多表关联，或者子查询，能否拆分。 2，加索引 3，做历史表 4，主从


2.  **Redis：** 如何使用Redis设计一个分布式锁？要注意哪些问题？
    - **考察点：** 分布式锁的原理和可靠性设计。
    - **参考答案：**
        - **基础命令：** `SET lock_key unique_value NX PX 30000` (NX表示不存在才设置，PX设置超时时间)。
        - **关键问题：**
            1.  **原子性：** 设置值和超时时间必须在一个命令中完成。
            2.  **误释放：** 释放锁时要检查value是否是自己设置的，使用Lua脚本保证原子性。
            3.  **超时时间：** 设置合理的超时，防止业务未执行完锁自动释放。
        - **进阶方案：** 对于极端可靠性要求，可以使用 **RedLock** 算法，但过于繁重，通常主从Redis+上述方案已足够。


3.  **Kafka/RocketMQ：** 如何保证消息的**顺序性**和**不重复消费**？
    - **考察点：** 对消息队列高级特性的理解。
    - **参考答案：**
        - **顺序性：**
            - **Kafka：** 将需要保证顺序的消息发送到同一个Partition（通过指定Key）。
            - **RocketMQ：** 使用**顺序消息**，将消息发到同一个MessageQueue。
        - **不重复消费（幂等性）：**
            - **根本原因：** 生产者重投或消费者重启导致。
            - **解决方案：** 在**消费者业务逻辑**中实现幂等。
                - **数据库：** 利用主键或唯一键约束。
                - **Redis：** 将消息唯一ID（如订单ID）写入Redis，处理前先查重。
   **消息队列 (Kafka/RocketMQ) (6分钟)**
   - **问题：** 如何保证消息队列的“消息不丢失”和“消息不重复消费”？
   - **考察点：** 对消息队列可靠性传输和幂等性设计的掌握。
   - **参考答案：**
     - **消息不丢失：**
       - **生产者：** 采用同步发送+确认机制（如Kafka的`acks=all`，RocketMQ的同步刷盘+主从同步）。
       - **Broker：** 设置多副本机制，确保主节点宕机后数据不丢失。
       - **消费者：** 先处理业务逻辑，再手动提交位移（commit offset）。
     - **消息不重复消费（幂等性）：**
       - **根本原因：** 网络问题导致生产者重试或消费者重启后位移未及时提交。
       - **解决方案：** 消息队列本身无法完全解决，需在**消费者业务逻辑中实现幂等**。
         - **利用数据库唯一键：** 在消息中携带唯一ID（如订单ID），插入数据库时利用唯一约束去重。
         - **利用Redis：** 将消息ID存入Redis，处理前先判断是否存在。


------------------------------------------------------------------------------------------------------------------------
##4** DevOps与云平台 (约5分钟)**


**1. Docker & Kubernetes (5分钟)**
   - **问题：** 在Kubernetes中，Deployment、Service和Ingress各自的作用是什么？它们是如何协作的？
   - **考察点：** 对K8s核心对象和网络模型的理解。
   - **参考答案：**
     - **Deployment：** 定义Pod的部署信息，如使用哪个镜像、有几个副本。它确保指定数量的Pod副本始终运行，并负责滚动更新和回滚。
     - **Service：** 为一组Pod提供稳定的网络端点（ClusterIP）。它通过标签选择器找到Pod，并提供负载均衡。Service使前端应用无需关心后端Pod的具体IP地址。
     - **Ingress：** 管理集群外部访问的API对象，提供HTTP/HTTPS路由规则。它相当于一个智能的7层负载均衡器，可以将不同域名或路径的流量路由到集群内部不同的Service。
     - **协作流程：** `外部用户 -> Ingress -> Service -> Pod (由Deployment管理)`。


**2. Jenkins & 公有云 (5分钟)**
   - **问题：** 请描述一个你熟悉的CI/CD流水线流程。在公有云（如AWS/Aliyun）上部署应用，与传统IDC部署相比，有哪些优势和你需要注意的地方？
   - **考察点：** CI/CD实践和云平台经验。
   - **参考答案：**
     - **CI/CD流程示例：** `开发者提交代码 -> Git -> Jenkins自动触发构建 -> 单元测试 -> 打包Docker镜像 -> 推送至镜像仓库 -> 更新K8s Deployment -> 健康检查 -> 服务上线`。
     - **公有云优势：**
       - **弹性与敏捷：** 快速申请和释放资源，按需付费。
       - **托管服务：** 直接使用云上的RDS、Redis、Kafka等服务，降低运维成本。
       - **全球部署：** 轻松实现多地域容灾。
     - **需要注意：**
       - **成本控制：** 资源闲置会导致浪费，需要完善的监控和预算管理。
       - **网络与安全：** 理解VPC、安全组等网络隔离和安全策略。
       - ** vendor-lock-in（厂商锁定）：** 尽量使用标准化的K8s等开源技术，减少对云厂商特有服务的依赖。


------------------------------------------------------------------------------------------------------------------------
##5**微服务/设计 (15分钟)**


    1.  **问题：** 请介绍一个您最近参与的、技术复杂度最高的Java项目。您在其中扮演什么角色？重点介绍一下它的微服务架构是如何划分的，以及为什么这样划分？（例如，是按业务领域、按功能还是其他？）
        - **考察点：**
            - **技术总结与沟通能力：** 能否清晰描述复杂系统。
            - **架构设计能力：** 对微服务拆分原则（如DDD、单一职责）的理解。
            - **技术决策能力：** 了解其技术选型的理由。
        - **参考答案：**
            - **角色：** 核心开发/架构师，负责XX服务的设计与实现。
            - **架构划分：** 我们采用**领域驱动设计（DDD）** 进行服务划分。例如，将系统划分为`用户中心`、`订单服务`、`商品服务`、`库存服务`和`支付服务`。
            - **原因：**
                - **高内聚低耦合：** 每个服务管理自己独立的业务领域和数据，边界清晰。
                - **独立部署与扩展：** “双十一”时，订单和支付服务可以独立扩容，而用户中心则不需要。
                - **技术多样性：** 不同的服务可以根据需求选择最合适的技术栈（虽然我们主要用Java）。


    2.  **追问：** 服务之间是如何通信的？在保证数据一致性方面遇到了哪些挑战，是如何解决的？
        - **考察点：** 对分布式系统核心问题的实践经验。
        - **参考答案：**
            - **通信：** 同步调用使用 **OpenFeign**（基于HTTP），异步通信使用 **RocketMQ/Kafka**。
            - **数据一致性（分布式事务）：**
                - **最终一致性（主流）：** 对于下单扣库存场景，我们采用**本地消息表**或直接使用**RocketMQ的事务消息**，保证核心流程的最终一致性。
                - **强一致性（少用）：** 对于账户扣款等场景，我们使用 **Seata** 的AT模式，但对性能有影响，需谨慎使用。


    微服务有哪些组件，启动顺序怎样的？ MQ --> Register --> Configure -->...


    **1. 系统设计 (5分钟)**
       - **问题：** 设计一个“秒杀系统”，要求支持瞬时高并发，并防止超卖。请简述核心设计思路。
       - **考察点：** 高并发系统架构能力，能否将前面讨论的技术串联起来解决问题。
       - **参考答案：**
         1. **架构原则：** 系统隔离、流量削峰、异步化、极致优化。
         2. **前端/网关层：**
            - 静态资源CDN加速。
            - 答题、验证码等手段防止机器人，削峰。
         3. **后端服务层：**
            - **独立秒杀服务：** 与主业务解耦。
            - **Redis预减库存：** 将商品库存加载到Redis中，用户下单时在Redis中原子性（`DECR`）扣减库存，快速判断是否还有库存，避免直接访问数据库。
            - **请求队列化：** 扣减库存成功的请求进入消息队列（Kafka/RocketMQ），实现异步削峰。
         4. **下游消费：**
            - 订单服务从队列中消费消息，完成创建订单、真实扣减数据库库存等后续流程。
         5. **防超卖：** 核心在于**Redis原子操作**和**数据库最终扣减时加乐观锁**（`update stock set stock = stock - 1 where id = ? and stock > 0`），双重保障。


    **2. 系统设计 (5分钟)**
       - **问题：** 设计一个数据处理系统，要求上传Excel的数据文件，数据有10万行，进行数据处理，然后存储到系统用来作报表展现，请简述核心设计思路。


    ** 解释一下CAP定理。 答:CAP定理指出一致性、可用性和分区容错性不可同时满足,最多只能同时满足两项。
    ** 分布式事务的实现策略有哪些? 答:2PC,3PC,可靠消息,TCC,SAGA,本地消息表等。


    ** 如何设计高可用系统


    ** 如何设计系统的Observability, 可观测性，全链路跟踪。

------------------------------------------------------------------------------------------------------------------------
##6** 反向提问与结束 (5分钟)**
   - **问题：** “我的问题问完了，您对我们团队、业务或者技术栈有什么想了解的吗？”
   - **考察点：** 候选人的求职意向和关注点。

====================================================================================================================================================
前端（可选）：
跨域报错如何解决？
ReactJs的状态管理如何做的？Redux怎么用的？
====================================================================================================================================================
大数据（可选）：
什么是数据倾斜?Map任务处理数据量大小不均衡。可通过combine操作优化。
几种常见的数据倾斜情况?数据分布不均、数据聚集、数据关联分析等导致数据负载不均衡。
====================================================================================================================================================
算法（可选）：
给定3个数字，输出三个数字拼接成的最大的数。比如：12， 3， 7 最大的数字应该是：7312
树数据结构的遍历，非递归如何遍历（堆栈+for循环）
有N个阶梯，一个人每一步只能走一个台阶或是两个台阶，问这个人上这个阶梯有多少种走法？
====================================================================================================================================================
** Open Questions: **
Technical Skills:
    * What projects have you worked on that showcase your development abilities and experience with various languages, frameworks, databases, etc?
    * Describe a technically complex feature or system you designed and implemented recently. What were some of the constraints and considerations? What technologies did you use and why?
    * How do you stay up-to-date on the latest languages, frameworks, and best practices in software development?
Honesty:
    * Tell me about a time you made a mistake on a project. What was the situation and how did you handle it?
    * Describe a situation where you had to choose between doing something the quick way or pushing to do it the right way. What was your approach and what was the outcome?
Willingness to Learn:
    * What new technologies or programming languages have you learned recently? What motivated you to learn them?
    * What resources do you rely on to keep expanding your software development knowledge?
Teamwork:
    * Tell me about a time you had to collaborate closely with other developers on a project. What was your role and how did you ensure smooth teamwork?
    * Describe a situation where you had to compromise with a teammate or adjust your work to fit with the team's objectives. How did you handle it?
Open-Mindedness:
    * Tell me about a time your viewpoint was changed on an aspect of software development or computing technology. What made you change your perspective?
    * Describe a situation where you had to consider an approach to a technical problem that was new or unfamiliar to you. How open were you to learning and trying it?
====================================================================================================================================================
**面试官评估总结 Checklist：**

| 维度 | 优秀表现 | 待考量表现 |
| :--- | :--- | :--- |
| **深度** | 能深入讲解原理（如三级缓存、B+树）、权衡利弊 | 仅停留在表面使用，说不清“为什么” |
| **广度** | 能串联起多个技术点（如MQ解决分布式事务） | 知识零散，无法建立联系 |
| **经验** | 能分享真实项目中的坑和解决方案 | 回答过于理论化，像在背书 |
| **逻辑** | 回答问题条理清晰，有结构化思维 | 思路混乱，答非所问 |
| **设计** | 代码和架构设计体现出良好的抽象和模式思想 | 缺乏设计意识，堆砌功能 |

===================================================================================================================================================
